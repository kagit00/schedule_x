<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
        xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-4.9.xsd">

    <!-- Step 11: Rename current potential_matches table to intermediate -->
    <changeSet id="20250607-01-rename-to-intermediate" author="grok">
        <preConditions onFail="MARK_RAN">
            <tableExists tableName="potential_matches"/>
        </preConditions>
        <renameTable
                oldTableName="potential_matches"
                newTableName="potential_matches_intermediate"/>
    </changeSet>

    <!-- Step 12: Create new potential_matches table with group_id as UUID -->
    <changeSet id="20250607-02-create-uuid-potential-matches" author="grok">
        <sql>
            <![CDATA[
                CREATE TABLE potential_matches (
                    id UUID NOT NULL,
                    group_id UUID NOT NULL,
                    domain_id UUID,
                    reference_id VARCHAR(50) NOT NULL,
                    matched_reference_id VARCHAR(50) NOT NULL,
                    compatibility_score DOUBLE PRECISION NOT NULL,
                    matched_at TIMESTAMP,
                    PRIMARY KEY (id, group_id)
                ) PARTITION BY LIST (group_id);
            ]]>
        </sql>
    </changeSet>

    <!-- Step 13: Create default partition for new table -->
    <changeSet id="20250607-03-create-uuid-default-partition" author="grok">
        <sql>
            <![CDATA[
                CREATE TABLE potential_matches_default
                PARTITION OF potential_matches DEFAULT;
            ]]>
        </sql>
    </changeSet>

    <!-- Step 14: Dynamically create partitions for UUID group_id using group_id for table names -->
    <changeSet id="20250607-04-create-uuid-partitions" author="grok">
        <sql splitStatements="false">
            <![CDATA[
                DO $$
                DECLARE
                    group_id_record RECORD;
                    sanitized_group_id TEXT;
                BEGIN
                    FOR group_id_record IN (
                        SELECT id, group_id
                        FROM matching_groups
                        WHERE id::text ~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
                    )
                    LOOP
                        -- Sanitize group_id to create a valid PostgreSQL identifier
                        sanitized_group_id := lower(regexp_replace(group_id_record.group_id, '[^a-zA-Z0-9_]', '_', 'g'));
                        -- Ensure the table name starts with a letter or underscore
                        IF sanitized_group_id ~ '^[0-9]' THEN
                            sanitized_group_id := 'part_' || sanitized_group_id;
                        END IF;
                        -- Truncate to avoid exceeding NAMEDATALEN (63 characters)
                        sanitized_group_id := left(sanitized_group_id, 59);
                        -- Create partition table
                        BEGIN
                            EXECUTE format(
                                'CREATE TABLE %I PARTITION OF potential_matches FOR VALUES IN (%L)',
                                'potential_matches_' || sanitized_group_id,
                                group_id_record.id
                            );
                        EXCEPTION WHEN others THEN
                            -- Log error and continue
                            RAISE NOTICE 'Failed to create partition for group_id % (id %): %', group_id_record.group_id, group_id_record.id, SQLERRM;
                            CONTINUE;
                        END;
                    END LOOP;
                END $$;
            ]]>
        </sql>
    </changeSet>

    <!-- Step 15: Migrate data with group_id cast to UUID -->
    <changeSet id="20250607-05-migrate-data-uuid" author="grok">
        <preConditions onFail="MARK_RAN">
            <tableExists tableName="potential_matches_intermediate"/>
        </preConditions>
        <sql splitStatements="false">
            <![CDATA[
                DO $$
                DECLARE
                    batch_size INTEGER := 10000;
                    total_rows INTEGER;
                    current_offset INTEGER := 0;
                    invalid_uuid_count INTEGER := 0;
                BEGIN
                    -- Check for invalid UUIDs
                    SELECT COUNT(*) INTO invalid_uuid_count
                    FROM potential_matches_intermediate
                    WHERE group_id::text !~ '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$';

                    IF invalid_uuid_count > 0 THEN
                        RAISE EXCEPTION 'Found % rows with invalid UUID format in group_id', invalid_uuid_count;
                    END IF;

                    -- Migrate data in batches
                    SELECT count(*) INTO total_rows FROM potential_matches_intermediate;
                    WHILE current_offset < total_rows LOOP
                        INSERT INTO potential_matches
                        SELECT
                            id,
                            group_id::UUID,
                            domain_id,
                            reference_id,
                            matched_reference_id,
                            compatibility_score,
                            matched_at
                        FROM potential_matches_intermediate
                        ORDER BY id
                        LIMIT batch_size OFFSET current_offset;
                        current_offset := current_offset + batch_size;
                        COMMIT;
                    END LOOP;
                END $$;
            ]]>
        </sql>
    </changeSet>

    <!-- Step 16: Drop intermediate table -->
    <changeSet id="20250607-06-drop-intermediate-table" author="grok">
        <preConditions onFail="MARK_RAN">
            <tableExists tableName="potential_matches_intermediate"/>
        </preConditions>
        <dropTable tableName="potential_matches_intermediate"/>
    </changeSet>

    <!-- Step 17: Re-apply unique constraint -->
    <changeSet id="20250607-07-reapply-unique-constraint" author="grok">
        <addUniqueConstraint
                tableName="potential_matches"
                columnNames="group_id, reference_id, matched_reference_id"
                constraintName="uq_potential_matches_unique_combination"/>
    </changeSet>

    <!-- Step 18: Re-create indexes for query performance -->
    <changeSet id="20250607-08-recreate-indexes" author="grok">
        <createIndex indexName="idx_potential_matches_group_id"
                     tableName="potential_matches">
            <column name="group_id"/>
        </createIndex>
        <createIndex indexName="idx_potential_matches_domain_id"
                     tableName="potential_matches">
            <column name="domain_id"/>
        </createIndex>
        <createIndex indexName="idx_potential_matches_reference_id"
                     tableName="potential_matches">
            <column name="reference_id"/>
        </createIndex>
        <createIndex indexName="idx_potential_matches_matched_reference_id"
                     tableName="potential_matches">
            <column name="matched_reference_id"/>
        </createIndex>
    </changeSet>

</databaseChangeLog>